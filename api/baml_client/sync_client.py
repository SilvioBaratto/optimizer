# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing

import baml_py

from . import stream_types, type_builder, types
from .globals import (
    DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME as __runtime__,
)
from .parser import LlmResponseParser, LlmStreamParser
from .runtime import BamlCallOptions, DoNotUseDirectlyCallManager


class BamlSyncClient:
    __options: DoNotUseDirectlyCallManager
    __stream_client: "BamlStreamClient"
    __http_request: "BamlHttpRequestClient"
    __http_stream_request: "BamlHttpStreamRequestClient"
    __llm_response_parser: LlmResponseParser
    __llm_stream_parser: LlmStreamParser

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options
        self.__stream_client = BamlStreamClient(options)
        self.__http_request = BamlHttpRequestClient(options)
        self.__http_stream_request = BamlHttpStreamRequestClient(options)
        self.__llm_response_parser = LlmResponseParser(options)
        self.__llm_stream_parser = LlmStreamParser(options)

    def __getstate__(self):
        # Return state needed for pickling
        return {"options": self.__options}

    def __setstate__(self, state):
        # Restore state from pickling
        self.__options = state["options"]
        self.__stream_client = BamlStreamClient(self.__options)
        self.__http_request = BamlHttpRequestClient(self.__options)
        self.__http_stream_request = BamlHttpStreamRequestClient(self.__options)
        self.__llm_response_parser = LlmResponseParser(self.__options)
        self.__llm_stream_parser = LlmStreamParser(self.__options)

    def with_options(
        self,
        tb: type_builder.TypeBuilder | None = None,
        client_registry: baml_py.baml_py.ClientRegistry | None = None,
        client: str | None = None,
        collector: baml_py.baml_py.Collector
        | list[baml_py.baml_py.Collector]
        | None = None,
        env: dict[str, str | None] | None = None,
        tags: dict[str, str] | None = None,
        on_tick: typing.Callable[[str, baml_py.baml_py.FunctionLog], None]
        | None = None,
    ) -> "BamlSyncClient":
        options: BamlCallOptions = {}
        if tb is not None:
            options["tb"] = tb
        if client_registry is not None:
            options["client_registry"] = client_registry
        if client is not None:
            options["client"] = client
        if collector is not None:
            options["collector"] = collector
        if env is not None:
            options["env"] = env
        if tags is not None:
            options["tags"] = tags
        if on_tick is not None:
            options["on_tick"] = on_tick
        return BamlSyncClient(self.__options.merge_options(options))

    @property
    def stream(self):
        return self.__stream_client

    @property
    def request(self):
        return self.__http_request

    @property
    def stream_request(self):
        return self.__http_stream_request

    @property
    def parse(self):
        return self.__llm_response_parser

    @property
    def parse_stream(self):
        return self.__llm_stream_parser

    def AdaptFactorWeights(
        self,
        macro_indicators: str,
        factor_groups: list[str],
        baml_options: BamlCallOptions = {},
    ) -> types.FactorWeightAdaptation:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.AdaptFactorWeights(
                macro_indicators=macro_indicators,
                factor_groups=factor_groups,
                baml_options=baml_options,
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="AdaptFactorWeights",
                args={
                    "macro_indicators": macro_indicators,
                    "factor_groups": factor_groups,
                },
            )
            return typing.cast(
                types.FactorWeightAdaptation,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def CalibrateDelta(
        self,
        macro_text: str,
        baml_options: BamlCallOptions = {},
    ) -> types.DeltaCalibration:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.CalibrateDelta(
                macro_text=macro_text, baml_options=baml_options
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="CalibrateDelta",
                args={
                    "macro_text": macro_text,
                },
            )
            return typing.cast(
                types.DeltaCalibration,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def CalibrateRiskBudget(
        self,
        sector_outlook: str,
        sector_universe: list[str],
        asset_sector_map: dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> types.RiskBudgetOutput:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.CalibrateRiskBudget(
                sector_outlook=sector_outlook,
                sector_universe=sector_universe,
                asset_sector_map=asset_sector_map,
                baml_options=baml_options,
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="CalibrateRiskBudget",
                args={
                    "sector_outlook": sector_outlook,
                    "sector_universe": sector_universe,
                    "asset_sector_map": asset_sector_map,
                },
            )
            return typing.cast(
                types.RiskBudgetOutput,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def ClassifyMacroRegime(
        self,
        macro_summary: str,
        baml_options: BamlCallOptions = {},
    ) -> types.MacroRegimeCalibration:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.ClassifyMacroRegime(
                macro_summary=macro_summary, baml_options=baml_options
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="ClassifyMacroRegime",
                args={
                    "macro_summary": macro_summary,
                },
            )
            return typing.cast(
                types.MacroRegimeCalibration,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def DesignStressScenarios(
        self,
        tickers: list[str],
        macro_context: str,
        n_scenarios: int,
        baml_options: BamlCallOptions = {},
    ) -> list["types.StressScenario"]:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.DesignStressScenarios(
                tickers=tickers,
                macro_context=macro_context,
                n_scenarios=n_scenarios,
                baml_options=baml_options,
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="DesignStressScenarios",
                args={
                    "tickers": tickers,
                    "macro_context": macro_context,
                    "n_scenarios": n_scenarios,
                },
            )
            return typing.cast(
                list["types.StressScenario"],
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def GenerateExpertView(
        self,
        assets: list["types.AssetFactorData"],
        persona: types.ExpertPersona,
        baml_options: BamlCallOptions = {},
    ) -> types.ViewOutput:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.GenerateExpertView(
                assets=assets, persona=persona, baml_options=baml_options
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="GenerateExpertView",
                args={
                    "assets": assets,
                    "persona": persona,
                },
            )
            return typing.cast(
                types.ViewOutput,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def GenerateMacroView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> types.ViewOutput:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.GenerateMacroView(
                assets=assets, baml_options=baml_options
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="GenerateMacroView",
                args={
                    "assets": assets,
                },
            )
            return typing.cast(
                types.ViewOutput,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def GenerateMomentumView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> types.ViewOutput:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.GenerateMomentumView(
                assets=assets, baml_options=baml_options
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="GenerateMomentumView",
                args={
                    "assets": assets,
                },
            )
            return typing.cast(
                types.ViewOutput,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def GenerateValueView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> types.ViewOutput:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.GenerateValueView(
                assets=assets, baml_options=baml_options
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="GenerateValueView",
                args={
                    "assets": assets,
                },
            )
            return typing.cast(
                types.ViewOutput,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def GenerateViews(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> types.ViewOutput:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.GenerateViews(
                assets=assets, baml_options=baml_options
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="GenerateViews",
                args={
                    "assets": assets,
                },
            )
            return typing.cast(
                types.ViewOutput,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def ScoreNewsSentiment(
        self,
        ticker: str,
        articles: list["types.NewsArticle"],
        baml_options: BamlCallOptions = {},
    ) -> types.NewsSentimentOutput:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.ScoreNewsSentiment(
                ticker=ticker, articles=articles, baml_options=baml_options
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="ScoreNewsSentiment",
                args={
                    "ticker": ticker,
                    "articles": articles,
                },
            )
            return typing.cast(
                types.NewsSentimentOutput,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )

    def SelectCovRegime(
        self,
        news_headlines: list[str],
        avg_sentiment_score: float,
        realized_vol_30d: float,
        baml_options: BamlCallOptions = {},
    ) -> types.CovRegimeSelection:
        # Check if on_tick is provided
        if "on_tick" in baml_options:
            __stream__ = self.stream.SelectCovRegime(
                news_headlines=news_headlines,
                avg_sentiment_score=avg_sentiment_score,
                realized_vol_30d=realized_vol_30d,
                baml_options=baml_options,
            )
            return __stream__.get_final_response()
        else:
            # Original non-streaming code
            __result__ = self.__options.merge_options(baml_options).call_function_sync(
                function_name="SelectCovRegime",
                args={
                    "news_headlines": news_headlines,
                    "avg_sentiment_score": avg_sentiment_score,
                    "realized_vol_30d": realized_vol_30d,
                },
            )
            return typing.cast(
                types.CovRegimeSelection,
                __result__.cast_to(types, types, stream_types, False, __runtime__),
            )


class BamlStreamClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AdaptFactorWeights(
        self,
        macro_indicators: str,
        factor_groups: list[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[
        stream_types.FactorWeightAdaptation, types.FactorWeightAdaptation
    ]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="AdaptFactorWeights",
            args={
                "macro_indicators": macro_indicators,
                "factor_groups": factor_groups,
            },
        )
        return baml_py.BamlSyncStream[
            stream_types.FactorWeightAdaptation, types.FactorWeightAdaptation
        ](
            __result__,
            lambda x: typing.cast(
                stream_types.FactorWeightAdaptation,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.FactorWeightAdaptation,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def CalibrateDelta(
        self,
        macro_text: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.DeltaCalibration, types.DeltaCalibration]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="CalibrateDelta",
            args={
                "macro_text": macro_text,
            },
        )
        return baml_py.BamlSyncStream[
            stream_types.DeltaCalibration, types.DeltaCalibration
        ](
            __result__,
            lambda x: typing.cast(
                stream_types.DeltaCalibration,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.DeltaCalibration,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def CalibrateRiskBudget(
        self,
        sector_outlook: str,
        sector_universe: list[str],
        asset_sector_map: dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.RiskBudgetOutput, types.RiskBudgetOutput]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="CalibrateRiskBudget",
            args={
                "sector_outlook": sector_outlook,
                "sector_universe": sector_universe,
                "asset_sector_map": asset_sector_map,
            },
        )
        return baml_py.BamlSyncStream[
            stream_types.RiskBudgetOutput, types.RiskBudgetOutput
        ](
            __result__,
            lambda x: typing.cast(
                stream_types.RiskBudgetOutput,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.RiskBudgetOutput,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def ClassifyMacroRegime(
        self,
        macro_summary: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[
        stream_types.MacroRegimeCalibration, types.MacroRegimeCalibration
    ]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="ClassifyMacroRegime",
            args={
                "macro_summary": macro_summary,
            },
        )
        return baml_py.BamlSyncStream[
            stream_types.MacroRegimeCalibration, types.MacroRegimeCalibration
        ](
            __result__,
            lambda x: typing.cast(
                stream_types.MacroRegimeCalibration,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.MacroRegimeCalibration,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def DesignStressScenarios(
        self,
        tickers: list[str],
        macro_context: str,
        n_scenarios: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[
        list["stream_types.StressScenario"], list["types.StressScenario"]
    ]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="DesignStressScenarios",
            args={
                "tickers": tickers,
                "macro_context": macro_context,
                "n_scenarios": n_scenarios,
            },
        )
        return baml_py.BamlSyncStream[
            list["stream_types.StressScenario"], list["types.StressScenario"]
        ](
            __result__,
            lambda x: typing.cast(
                list["stream_types.StressScenario"],
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                list["types.StressScenario"],
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def GenerateExpertView(
        self,
        assets: list["types.AssetFactorData"],
        persona: types.ExpertPersona,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="GenerateExpertView",
            args={
                "assets": assets,
                "persona": persona,
            },
        )
        return baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput](
            __result__,
            lambda x: typing.cast(
                stream_types.ViewOutput,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.ViewOutput,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def GenerateMacroView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="GenerateMacroView",
            args={
                "assets": assets,
            },
        )
        return baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput](
            __result__,
            lambda x: typing.cast(
                stream_types.ViewOutput,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.ViewOutput,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def GenerateMomentumView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="GenerateMomentumView",
            args={
                "assets": assets,
            },
        )
        return baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput](
            __result__,
            lambda x: typing.cast(
                stream_types.ViewOutput,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.ViewOutput,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def GenerateValueView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="GenerateValueView",
            args={
                "assets": assets,
            },
        )
        return baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput](
            __result__,
            lambda x: typing.cast(
                stream_types.ViewOutput,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.ViewOutput,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def GenerateViews(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="GenerateViews",
            args={
                "assets": assets,
            },
        )
        return baml_py.BamlSyncStream[stream_types.ViewOutput, types.ViewOutput](
            __result__,
            lambda x: typing.cast(
                stream_types.ViewOutput,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.ViewOutput,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def ScoreNewsSentiment(
        self,
        ticker: str,
        articles: list["types.NewsArticle"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[
        stream_types.NewsSentimentOutput, types.NewsSentimentOutput
    ]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="ScoreNewsSentiment",
            args={
                "ticker": ticker,
                "articles": articles,
            },
        )
        return baml_py.BamlSyncStream[
            stream_types.NewsSentimentOutput, types.NewsSentimentOutput
        ](
            __result__,
            lambda x: typing.cast(
                stream_types.NewsSentimentOutput,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.NewsSentimentOutput,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )

    def SelectCovRegime(
        self,
        news_headlines: list[str],
        avg_sentiment_score: float,
        realized_vol_30d: float,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[
        stream_types.CovRegimeSelection, types.CovRegimeSelection
    ]:
        __ctx__, __result__ = self.__options.merge_options(
            baml_options
        ).create_sync_stream(
            function_name="SelectCovRegime",
            args={
                "news_headlines": news_headlines,
                "avg_sentiment_score": avg_sentiment_score,
                "realized_vol_30d": realized_vol_30d,
            },
        )
        return baml_py.BamlSyncStream[
            stream_types.CovRegimeSelection, types.CovRegimeSelection
        ](
            __result__,
            lambda x: typing.cast(
                stream_types.CovRegimeSelection,
                x.cast_to(types, types, stream_types, True, __runtime__),
            ),
            lambda x: typing.cast(
                types.CovRegimeSelection,
                x.cast_to(types, types, stream_types, False, __runtime__),
            ),
            __ctx__,
        )


class BamlHttpRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AdaptFactorWeights(
        self,
        macro_indicators: str,
        factor_groups: list[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="AdaptFactorWeights",
            args={
                "macro_indicators": macro_indicators,
                "factor_groups": factor_groups,
            },
            mode="request",
        )
        return __result__

    def CalibrateDelta(
        self,
        macro_text: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="CalibrateDelta",
            args={
                "macro_text": macro_text,
            },
            mode="request",
        )
        return __result__

    def CalibrateRiskBudget(
        self,
        sector_outlook: str,
        sector_universe: list[str],
        asset_sector_map: dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="CalibrateRiskBudget",
            args={
                "sector_outlook": sector_outlook,
                "sector_universe": sector_universe,
                "asset_sector_map": asset_sector_map,
            },
            mode="request",
        )
        return __result__

    def ClassifyMacroRegime(
        self,
        macro_summary: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="ClassifyMacroRegime",
            args={
                "macro_summary": macro_summary,
            },
            mode="request",
        )
        return __result__

    def DesignStressScenarios(
        self,
        tickers: list[str],
        macro_context: str,
        n_scenarios: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="DesignStressScenarios",
            args={
                "tickers": tickers,
                "macro_context": macro_context,
                "n_scenarios": n_scenarios,
            },
            mode="request",
        )
        return __result__

    def GenerateExpertView(
        self,
        assets: list["types.AssetFactorData"],
        persona: types.ExpertPersona,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateExpertView",
            args={
                "assets": assets,
                "persona": persona,
            },
            mode="request",
        )
        return __result__

    def GenerateMacroView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateMacroView",
            args={
                "assets": assets,
            },
            mode="request",
        )
        return __result__

    def GenerateMomentumView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateMomentumView",
            args={
                "assets": assets,
            },
            mode="request",
        )
        return __result__

    def GenerateValueView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateValueView",
            args={
                "assets": assets,
            },
            mode="request",
        )
        return __result__

    def GenerateViews(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateViews",
            args={
                "assets": assets,
            },
            mode="request",
        )
        return __result__

    def ScoreNewsSentiment(
        self,
        ticker: str,
        articles: list["types.NewsArticle"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="ScoreNewsSentiment",
            args={
                "ticker": ticker,
                "articles": articles,
            },
            mode="request",
        )
        return __result__

    def SelectCovRegime(
        self,
        news_headlines: list[str],
        avg_sentiment_score: float,
        realized_vol_30d: float,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="SelectCovRegime",
            args={
                "news_headlines": news_headlines,
                "avg_sentiment_score": avg_sentiment_score,
                "realized_vol_30d": realized_vol_30d,
            },
            mode="request",
        )
        return __result__


class BamlHttpStreamRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AdaptFactorWeights(
        self,
        macro_indicators: str,
        factor_groups: list[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="AdaptFactorWeights",
            args={
                "macro_indicators": macro_indicators,
                "factor_groups": factor_groups,
            },
            mode="stream",
        )
        return __result__

    def CalibrateDelta(
        self,
        macro_text: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="CalibrateDelta",
            args={
                "macro_text": macro_text,
            },
            mode="stream",
        )
        return __result__

    def CalibrateRiskBudget(
        self,
        sector_outlook: str,
        sector_universe: list[str],
        asset_sector_map: dict[str, str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="CalibrateRiskBudget",
            args={
                "sector_outlook": sector_outlook,
                "sector_universe": sector_universe,
                "asset_sector_map": asset_sector_map,
            },
            mode="stream",
        )
        return __result__

    def ClassifyMacroRegime(
        self,
        macro_summary: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="ClassifyMacroRegime",
            args={
                "macro_summary": macro_summary,
            },
            mode="stream",
        )
        return __result__

    def DesignStressScenarios(
        self,
        tickers: list[str],
        macro_context: str,
        n_scenarios: int,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="DesignStressScenarios",
            args={
                "tickers": tickers,
                "macro_context": macro_context,
                "n_scenarios": n_scenarios,
            },
            mode="stream",
        )
        return __result__

    def GenerateExpertView(
        self,
        assets: list["types.AssetFactorData"],
        persona: types.ExpertPersona,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateExpertView",
            args={
                "assets": assets,
                "persona": persona,
            },
            mode="stream",
        )
        return __result__

    def GenerateMacroView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateMacroView",
            args={
                "assets": assets,
            },
            mode="stream",
        )
        return __result__

    def GenerateMomentumView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateMomentumView",
            args={
                "assets": assets,
            },
            mode="stream",
        )
        return __result__

    def GenerateValueView(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateValueView",
            args={
                "assets": assets,
            },
            mode="stream",
        )
        return __result__

    def GenerateViews(
        self,
        assets: list["types.AssetFactorData"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="GenerateViews",
            args={
                "assets": assets,
            },
            mode="stream",
        )
        return __result__

    def ScoreNewsSentiment(
        self,
        ticker: str,
        articles: list["types.NewsArticle"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="ScoreNewsSentiment",
            args={
                "ticker": ticker,
                "articles": articles,
            },
            mode="stream",
        )
        return __result__

    def SelectCovRegime(
        self,
        news_headlines: list[str],
        avg_sentiment_score: float,
        realized_vol_30d: float,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        __result__ = self.__options.merge_options(
            baml_options
        ).create_http_request_sync(
            function_name="SelectCovRegime",
            args={
                "news_headlines": news_headlines,
                "avg_sentiment_score": avg_sentiment_score,
                "realized_vol_30d": realized_vol_30d,
            },
            mode="stream",
        )
        return __result__


b = BamlSyncClient(DoNotUseDirectlyCallManager({}))
